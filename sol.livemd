<!-- livebook:{"file_entries":[{"file":{"file_system_id":"local","file_system_type":"local","path":"/home/bre/Dev/advent-of-code-2023/day 1/input.txt"},"name":"day_1_input.txt","type":"file"},{"file":{"file_system_id":"local","file_system_type":"local","path":"/home/bre/Dev/advent-of-code-2023/day 2/input.txt"},"name":"day_2_input.txt","type":"file"},{"file":{"file_system_id":"local","file_system_type":"local","path":"/home/bre/Dev/advent-of-code-2023/day 3/input.txt"},"name":"day_3_input.txt","type":"file"},{"file":{"file_system_id":"local","file_system_type":"local","path":"/home/bre/Dev/advent-of-code-2023/day 4/input.txt"},"name":"day_4_input.txt","type":"file"},{"file":{"file_system_id":"local","file_system_type":"local","path":"/home/bre/Dev/advent-of-code-2023/day 5/input.txt"},"name":"day_5_input.txt","type":"file"},{"file":{"file_system_id":"local","file_system_type":"local","path":"/home/bre/Dev/advent-of-code-2023/day 6/input.txt"},"name":"day_6_input.txt","type":"file"},{"file":{"file_system_id":"local","file_system_type":"local","path":"/home/bre/Dev/advent-of-code-2023/day 6/example1.txt"},"name":"example1.txt","type":"file"}]} -->

# AoC 2023

```elixir
Mix.install([
  {:kino, "~> 0.11.3"}
])
```

## Day 1

```elixir
input =
  Kino.FS.file_path("day_1_input.txt")
  |> File.read!()
  |> String.split("\n")
```

```elixir
defmodule Day1 do
  def run(input) do
    part_1 =
      input
      |> Enum.map(&leave_only_numbers/1)
      |> Enum.map(&format_numbers/1)
      |> Enum.sum()

    part_2 =
      input
      |> Enum.map(&written_number_to_number_string/1)
      |> Enum.map(&leave_only_numbers/1)
      |> Enum.map(&format_numbers/1)
      |> Enum.sum()

    {part_1, part_2}
  end

  defp written_number_to_number_string(string) do
    string
    |> String.replace("one", "o1e")
    |> String.replace("two", "t2o")
    |> String.replace("three", "t3e")
    |> String.replace("four", "f4r")
    |> String.replace("five", "f5e")
    |> String.replace("six", "s6x")
    |> String.replace("seven", "s7n")
    |> String.replace("eight", "e8t")
    |> String.replace("nine", "n9e")
  end

  defp leave_only_numbers(string) do
    String.replace(string, ~r/[^0-9]/, "")
  end

  defp format_numbers(""), do: 0

  defp format_numbers(string) do
    (String.at(string, 0) <> String.at(string, String.length(string) - 1))
    |> Integer.parse()
    |> elem(0)
  end
end
```

```elixir
Day1.run(input)
```

## Day 2

```elixir
constrains = %{
  red: 12,
  green: 13,
  blue: 14
}

input =
  Kino.FS.file_path("day_2_input.txt")
  |> File.read!()
  |> String.split("\n")
```

```elixir
defmodule Day2 do
  def run(input, constrains) do
    part_1 =
      input
      |> Enum.reduce(%{}, &get_game_info/2)
      |> Enum.filter(&is_game_possible?(&1, constrains))
      |> Enum.map(&elem(&1, 0))
      |> Enum.sum()

    part_2 =
      input
      |> Enum.reduce(%{}, &get_game_info/2)
      |> Enum.map(
        &(elem(&1, 1)
          |> calculate_fewest_to_make_possible()
          |> Map.values()
          |> Enum.product())
      )
      |> Enum.sum()

    {part_1, part_2}
  end

  defp calculate_fewest_to_make_possible(game_info) do
    Enum.reduce(game_info, %{red: 0, green: 0, blue: 0}, fn play, acc ->
      %{
        red: Enum.max([Map.get(play, :red) || 0, Map.get(acc, :red)]),
        green: Enum.max([Map.get(play, :green) || 0, Map.get(acc, :green)]),
        blue: Enum.max([Map.get(play, :blue) || 0, Map.get(acc, :blue)])
      }
    end)
  end

  defp is_game_possible?(game, constrains) do
    game
    |> elem(1)
    |> Enum.map(fn play ->
      (Map.get(play, :red) || 0) <= (Map.get(constrains, :red) || 0) &&
        (Map.get(play, :green) || 0) <= (Map.get(constrains, :green) || 0) &&
        (Map.get(play, :blue) || 0) <= (Map.get(constrains, :blue) || 0)
    end)
    |> Enum.all?()
  end

  # "Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green"
  defp get_game_info(game_string, recursive_map) do
    [game_hd | game_tl] = String.split(game_string, ": ")
    game_tl = Enum.at(game_tl, 0)
    game_number = game_hd |> String.replace("Game ", "") |> Integer.parse() |> elem(0)
    game_info = game_tl |> String.split("; ") |> Enum.map(&get_play_info/1)

    Map.put(recursive_map, game_number, game_info)
  end

  # "3 blue, 4 red"
  defp get_play_info(play_string) do
    play_string
    |> String.split(", ")
    |> Enum.reduce(%{}, &accumulate_play_info/2)
  end

  # "3 blue, %{} -> %{blue: 3}
  defp accumulate_play_info(play, acc) do
    [number, color] = String.split(play, " ")
    Map.put(acc, String.to_atom(color), Integer.parse(number) |> elem(0))
  end
end
```

```elixir
Day2.run(input, constrains)
```

## Day 3

```elixir
input =
  Kino.FS.file_path("day_3_input.txt")
  |> File.read!()
  |> String.split("\n")
  |> Enum.filter(&(&1 != ""))
```

```elixir
defmodule Day3 do
  require Logger

  def run(input) do
    row_range = Enum.to_list(0..(length(input) - 1))

    part_1 =
      row_range
      |> Enum.reduce([], &generate_all_checks(input, &1, &2))
      |> Enum.filter(&filter_with_checks(input, &1))
      |> Enum.map(&Map.get(&1, :number))
      |> Enum.sum()

    part_2 =
      row_range
      |> Enum.reduce([], &generate_all_checks(input, &1, &2))
      |> Enum.reduce(%{}, &asterisk_transformation(input, &1, &2))
      |> Map.values()
      |> Enum.filter(&(length(&1) === 2))
      |> Enum.map(&Enum.product/1)
      |> Enum.sum()

    {part_1, part_2}
  end

  defp asterisk_transformation(input, check_map, accumulator) do
    checks = Map.get(check_map, :check)
    number = Map.get(check_map, :number)

    checks
    |> Enum.reduce(accumulator, fn {row, col}, acc ->
      line = Enum.at(input, row)
      char = String.at(line, col)

      with :error <- Integer.parse(char),
           true <- char === "*" do
        key = inspect({row, col})
        value = Map.get(acc, key, []) ++ [number]

        Map.put(acc, key, value)
      else
        _ -> acc
      end
    end)
  end

  defp filter_with_checks(input, check_map) do
    Map.get(check_map, :check)
    |> Enum.map(fn {row, col} ->
      line = Enum.at(input, row)
      char = String.at(line, col)

      with :error <- Integer.parse(char),
           true <- char !== "." do
        true
      else
        _ -> false
      end
    end)
    |> Enum.any?(& &1)
  end

  defp generate_all_checks(input, row_number, accumulator) do
    numbers_col_start_and_size = get_numbers_placement_per_row(input, row_number)

    line = Enum.at(input, row_number)

    row_checks =
      Enum.reduce(numbers_col_start_and_size, [], fn tuple, acc ->
        [col_start, size] = [elem(tuple, 0), elem(tuple, 1)]
        col_end = col_start + size
        max_row = length(input) - 1
        max_col = String.length(line) - 1

        [
          %{
            number: String.slice(line, col_start, size) |> String.to_integer(),
            check: generate_el_checks(row_number, col_start, col_end, max_row, max_col)
          }
          | acc
        ]
      end)

    row_checks ++ accumulator
  end

  defp generate_el_checks(row, col_start, col_end, max_row, max_col) do
    row_above = Enum.max([0, row - 1])
    row_below = Enum.min([max_row, row + 1])

    col_before = Enum.max([0, col_start - 1])
    col_after = Enum.min([max_col, col_end])

    range = Enum.to_list(col_before..col_after)

    [row_above, row, row_below]
    |> Enum.uniq_by(& &1)
    |> Enum.flat_map(fn row_number -> Enum.map(range, fn index -> {row_number, index} end) end)
  end

  defp get_numbers_placement_per_row(input, row) do
    Regex.scan(~r/\d+/, Enum.at(input, row), return: :index)
    |> Enum.map(&Enum.at(&1, 0))
  end
end
```

```elixir
Day3.run(input)
```

## Day 4

```elixir
input =
  Kino.FS.file_path("day_4_input.txt")
  |> File.read!()
  |> String.split("\n")
  |> Enum.filter(&(&1 != ""))
```

```elixir
require Logger

defmodule Day4 do
  def run(input) do
    part_1 =
      input
      |> Enum.map(fn card ->
        [hd, tl] = String.split(card, " | ")

        get_winning_numbers(hd)
        |> calculate_num_of_matches(get_my_numbers(tl))
        |> calculate_score()
      end)
      |> Enum.sum()

    quantities_per_card = input |> Enum.map(fn _ -> 1 end)

    part_2 =
      input
      |> Enum.with_index()
      |> Enum.reduce(quantities_per_card, fn {card, card_index}, acc ->
        [hd, tl] = String.split(card, " | ")
        num_of_matches = calculate_num_of_matches(get_winning_numbers(hd), get_my_numbers(tl))

        case num_of_matches do
          0 ->
            acc

          n ->
            curr_list = acc
            positions_to_increase = Enum.to_list((card_index + 1)..(card_index + n))
            amount_to_increase = Enum.at(acc, card_index)

            increase_numerical_list_at_positions(
              curr_list,
              positions_to_increase,
              amount_to_increase
            )
        end
      end)
      |> Enum.sum()

    {part_1, part_2}
  end

  defp get_winning_numbers(string) do
    string
    |> String.split(": ")
    |> Enum.at(1)
    |> String.split(" ")
    |> Enum.filter(&(&1 != ""))
    |> Enum.map(&String.to_integer/1)
  end

  defp get_my_numbers(string) do
    string
    |> String.split(" ")
    |> Enum.filter(&(&1 != ""))
    |> Enum.map(&String.to_integer/1)
  end

  defp calculate_num_of_matches(winning_numbers, my_numbers) do
    Enum.reduce(my_numbers, 0, fn my_num, acc ->
      case Enum.find(winning_numbers, &(&1 === my_num)) do
        nil ->
          acc

        _ ->
          acc + 1
      end
    end)
  end

  defp calculate_score(num_of_matches) do
    case num_of_matches do
      0 -> 0
      p -> 2 ** (p - 1)
    end
  end

  defp increase_numerical_list_at_positions(list, positions, increment) do
    Enum.with_index(list, fn el, idx ->
      case Enum.find(positions, &(&1 === idx)) do
        nil -> el
        _ -> el + increment
      end
    end)
  end
end
```

```elixir
Day4.run(input)
```

## Day 5

```elixir
input =
  Kino.FS.file_path("day_5_input.txt")
  |> File.read!()
  |> String.split("\n")
```

```elixir
defmodule Day5 do
  def run(input) do
    triples = get_triples(input)
    part_1 = exec(get_tuples_for_part_1(input), triples)
    part_2 = exec(get_tuples(input), triples)

    {part_1, part_2}
  end

  defp exec(tuples, triples) do
    triples
    |> Enum.reduce(tuples, fn triple, acc ->
      acc
      |> chop_tuples_from_triples(triple)
      |> apply_triples_in_tuples(triple)
    end)
    |> Enum.sort(fn {minA, _}, {minB, _} -> minA <= minB end)
    |> Enum.at(0)
    |> elem(0)
  end

  defp get_tuples_for_part_1(input) do
    input
    |> Enum.at(0)
    |> String.split(": ")
    |> Enum.at(1)
    |> String.split(" ")
    |> Enum.map(&String.to_integer/1)
    |> Enum.map(fn el -> {el, el} end)
  end

  defp get_tuples(input) do
    input
    |> Enum.at(0)
    |> String.split(": ")
    |> Enum.at(1)
    |> String.split(" ")
    |> Enum.map(&String.to_integer/1)
    |> Enum.chunk_every(2)
    |> Enum.map(fn chunk -> {Enum.at(chunk, 0), Enum.at(chunk, 0) + Enum.at(chunk, 1) - 1} end)
  end

  defp get_triples(input) do
    [_ | maps] =
      input
      |> Enum.chunk_by(&(&1 === ""))
      |> Enum.filter(fn arr -> Enum.all?(arr, fn el -> el !== "" end) end)

    maps
    |> Enum.map(fn [_ | tl] ->
      Enum.map(tl, fn el ->
        el
        |> String.split(" ")
        |> Enum.map(&String.to_integer/1)
      end)
      |> Enum.map(fn [target, source, length] ->
        {source, source + length - 1, target - source}
      end)
    end)
  end

  defp chop_tuple_from_triple(tuple, triple) do
    {triple_min, triple_max, _} = triple
    {tuple_min, tuple_max} = tuple

    cond do
      tuple_max < triple_min or tuple_min > triple_max ->
        [tuple]

      triple_min <= tuple_min and tuple_max <= triple_max ->
        [tuple]

      tuple_min < triple_min and tuple_max <= triple_max ->
        [
          {tuple_min, triple_min - 1},
          {triple_min, tuple_max}
        ]

      triple_min <= tuple_min and triple_max < tuple_max ->
        [
          {tuple_min, triple_max},
          {triple_max + 1, tuple_max}
        ]

      tuple_min < triple_min and triple_max < tuple_max ->
        [
          {tuple_min, triple_min - 1},
          {triple_min, triple_max},
          {triple_max + 1, tuple_max}
        ]
    end
  end

  defp chop_tuples_from_triple(tuples, triple) do
    Enum.flat_map(tuples, &chop_tuple_from_triple(&1, triple))
  end

  defp chop_tuple_from_triples(tuple, triples) do
    Enum.reduce(triples, [tuple], &chop_tuples_from_triple(&2, &1))
  end

  defp chop_tuples_from_triples(tuples, triples) do
    Enum.flat_map(tuples, &chop_tuple_from_triples(&1, triples))
  end

  defp apply_triple_in_tuple(tuple, triple) do
    {triple_min, triple_max, increment} = triple
    {tuple_min, tuple_max} = tuple

    cond do
      triple_min <= tuple_min and tuple_max <= triple_max ->
        new_tuple_min = tuple_min + increment
        new_tuple_max = tuple_max + increment
        {Enum.min([new_tuple_min, new_tuple_max]), Enum.max([new_tuple_min, new_tuple_max])}

      true ->
        tuple
    end
  end

  defp apply_triples_in_tuple(tuple, triples) do
    new_tuples = Enum.map(triples, &apply_triple_in_tuple(tuple, &1))
    contain_new? = Enum.any?(new_tuples, fn t -> t !== tuple end)

    case contain_new? do
      true -> Enum.filter(new_tuples, fn t -> t !== tuple end)
      false -> new_tuples |> Enum.uniq()
    end
  end

  defp apply_triples_in_tuples(tuples, triples) do
    Enum.flat_map(tuples, &apply_triples_in_tuple(&1, triples))
  end
end
```

```elixir
Day5.run(input)
```

## Day 6

```elixir
input =
  Kino.FS.file_path("day_6_input.txt")
  |> File.read!()
  |> String.split("\n")
```

```elixir
defmodule Day6 do
  def run(input) do
    part_1 = get_list_of_tuples_part_1(input) |> exec()
    part_2 = get_list_of_tuples_part_2(input) |> exec()

    {part_1, part_2}
  end

  defp exec(list_of_tuples) do
    list_of_tuples
    |> Enum.map(fn {max_time, distance_record} ->
      Enum.to_list(0..max_time)
      |> Enum.map(&calculate_distance(&1, max_time))
      |> Enum.count(&(&1 > distance_record))
    end)
    |> Enum.product()
  end

  defp get_list_of_tuples_part_1(input) do
    [times, distances] =
      input
      |> Enum.map(fn str ->
        str
        |> String.replace(~r/\s\s+/, " ")
        |> String.split(": ")
        |> Enum.at(1)
        |> String.split(" ")
        |> Enum.map(&String.to_integer/1)
      end)

    Enum.zip(times, distances)
  end

  defp get_list_of_tuples_part_2(input) do
    [times, distances] =
      input
      |> Enum.map(fn str ->
        str
        |> String.replace(~r/\s\s+/, " ")
        |> String.split(": ")
        |> Enum.at(1)
        |> String.replace(" ", "")
        |> String.to_integer()
      end)

    [{times, distances}]
  end

  defp calculate_distance(time_holding_button, max_time) do
    cond do
      time_holding_button === 0 -> 0
      true -> (max_time - time_holding_button) * time_holding_button
    end
  end
end
```

```elixir
Day6.run(input)
```

<!-- livebook:{"offset":15127,"stamp":{"token":"XCP.ke_fUJIx6vAMyOvDPhGOEfRnExlYJAd1kVdcTXAmiLVrcB1WVJKtrEdb-ad5PaLePHXb25F5LCC2mUjnil539siKn8dZCBgBe9lzwpA","version":2}} -->

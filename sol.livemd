<!-- livebook:{"file_entries":[{"file":{"file_system_id":"local","file_system_type":"local","path":"/home/bre/Dev/advent-of-code-2023/day 1/input.txt"},"name":"day_1_input.txt","type":"file"},{"file":{"file_system_id":"local","file_system_type":"local","path":"/home/bre/Dev/advent-of-code-2023/day 2/input.txt"},"name":"day_2_input.txt","type":"file"},{"file":{"file_system_id":"local","file_system_type":"local","path":"/home/bre/Dev/advent-of-code-2023/day 3/input.txt"},"name":"day_3_input.txt","type":"file"},{"file":{"file_system_id":"local","file_system_type":"local","path":"/home/bre/Dev/advent-of-code-2023/day 4/input.txt"},"name":"day_4_input.txt","type":"file"}]} -->

# AoC 2023

```elixir
Mix.install([
  {:kino, "~> 0.11.3"}
])
```

## Day 1

```elixir
input =
  Kino.FS.file_path("day_1_input.txt")
  |> File.read!()
  |> String.split("\n")
```

```elixir
defmodule Day1 do
  def run(input) do
    part_1 =
      input
      |> Enum.map(&leave_only_numbers/1)
      |> Enum.map(&format_numbers/1)
      |> Enum.sum()

    part_2 =
      input
      |> Enum.map(&written_number_to_number_string/1)
      |> Enum.map(&leave_only_numbers/1)
      |> Enum.map(&format_numbers/1)
      |> Enum.sum()

    {part_1, part_2}
  end

  defp written_number_to_number_string(string) do
    string
    |> String.replace("one", "o1e")
    |> String.replace("two", "t2o")
    |> String.replace("three", "t3e")
    |> String.replace("four", "f4r")
    |> String.replace("five", "f5e")
    |> String.replace("six", "s6x")
    |> String.replace("seven", "s7n")
    |> String.replace("eight", "e8t")
    |> String.replace("nine", "n9e")
  end

  defp leave_only_numbers(string) do
    String.replace(string, ~r/[^0-9]/, "")
  end

  defp format_numbers(""), do: 0

  defp format_numbers(string) do
    (String.at(string, 0) <> String.at(string, String.length(string) - 1))
    |> Integer.parse()
    |> elem(0)
  end
end
```

```elixir
Day1.run(input)
```

## Day 2

```elixir
constrains = %{
  red: 12,
  green: 13,
  blue: 14
}

input =
  Kino.FS.file_path("day_2_input.txt")
  |> File.read!()
  |> String.split("\n")
```

```elixir
defmodule Day2 do
  def run(input, constrains) do
    part_1 =
      input
      |> Enum.reduce(%{}, &get_game_info/2)
      |> Enum.filter(&is_game_possible?(&1, constrains))
      |> Enum.map(&elem(&1, 0))
      |> Enum.sum()

    part_2 =
      input
      |> Enum.reduce(%{}, &get_game_info/2)
      |> Enum.map(
        &(elem(&1, 1)
          |> calculate_fewest_to_make_possible()
          |> Map.values()
          |> Enum.product())
      )
      |> Enum.sum()

    {part_1, part_2}
  end

  defp calculate_fewest_to_make_possible(game_info) do
    Enum.reduce(game_info, %{red: 0, green: 0, blue: 0}, fn play, acc ->
      %{
        red: Enum.max([Map.get(play, :red) || 0, Map.get(acc, :red)]),
        green: Enum.max([Map.get(play, :green) || 0, Map.get(acc, :green)]),
        blue: Enum.max([Map.get(play, :blue) || 0, Map.get(acc, :blue)])
      }
    end)
  end

  defp is_game_possible?(game, constrains) do
    game
    |> elem(1)
    |> Enum.map(fn play ->
      (Map.get(play, :red) || 0) <= (Map.get(constrains, :red) || 0) &&
        (Map.get(play, :green) || 0) <= (Map.get(constrains, :green) || 0) &&
        (Map.get(play, :blue) || 0) <= (Map.get(constrains, :blue) || 0)
    end)
    |> Enum.all?()
  end

  # "Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green"
  defp get_game_info(game_string, recursive_map) do
    [game_hd | game_tl] = String.split(game_string, ": ")
    game_tl = Enum.at(game_tl, 0)
    game_number = game_hd |> String.replace("Game ", "") |> Integer.parse() |> elem(0)
    game_info = game_tl |> String.split("; ") |> Enum.map(&get_play_info/1)

    Map.put(recursive_map, game_number, game_info)
  end

  # "3 blue, 4 red"
  defp get_play_info(play_string) do
    play_string
    |> String.split(", ")
    |> Enum.reduce(%{}, &accumulate_play_info/2)
  end

  # "3 blue, %{} -> %{blue: 3}
  defp accumulate_play_info(play, acc) do
    [number, color] = String.split(play, " ")
    Map.put(acc, String.to_atom(color), Integer.parse(number) |> elem(0))
  end
end
```

```elixir
Day2.run(input, constrains)
```

## Day 3

```elixir
input =
  Kino.FS.file_path("day_3_input.txt")
  |> File.read!()
  |> String.split("\n")
  |> Enum.filter(&(&1 != ""))
```

```elixir
defmodule Day3 do
  require Logger

  def run(input) do
    row_range = Enum.to_list(0..(length(input) - 1))

    part_1 =
      row_range
      |> Enum.reduce([], &generate_all_checks(input, &1, &2))
      |> Enum.filter(&filter_with_checks(input, &1))
      |> Enum.map(&Map.get(&1, :number))
      |> Enum.sum()

    part_2 =
      row_range
      |> Enum.reduce([], &generate_all_checks(input, &1, &2))
      |> Enum.reduce(%{}, &asterisk_transformation(input, &1, &2))
      |> Map.values()
      |> Enum.filter(&(length(&1) === 2))
      |> Enum.map(&Enum.product/1)
      |> Enum.sum()

    {part_1, part_2}
  end

  defp asterisk_transformation(input, check_map, accumulator) do
    checks = Map.get(check_map, :check)
    number = Map.get(check_map, :number)

    checks
    |> Enum.reduce(accumulator, fn {row, col}, acc ->
      line = Enum.at(input, row)
      char = String.at(line, col)

      with :error <- Integer.parse(char),
           true <- char === "*" do
        key = inspect({row, col})
        value = Map.get(acc, key, []) ++ [number]

        Map.put(acc, key, value)
      else
        _ -> acc
      end
    end)
  end

  defp filter_with_checks(input, check_map) do
    Map.get(check_map, :check)
    |> Enum.map(fn {row, col} ->
      line = Enum.at(input, row)
      char = String.at(line, col)

      with :error <- Integer.parse(char),
           true <- char !== "." do
        true
      else
        _ -> false
      end
    end)
    |> Enum.any?(& &1)
  end

  defp generate_all_checks(input, row_number, accumulator) do
    numbers_col_start_and_size = get_numbers_placement_per_row(input, row_number)

    line = Enum.at(input, row_number)

    row_checks =
      Enum.reduce(numbers_col_start_and_size, [], fn tuple, acc ->
        [col_start, size] = [elem(tuple, 0), elem(tuple, 1)]
        col_end = col_start + size
        max_row = length(input) - 1
        max_col = String.length(line) - 1

        [
          %{
            number: String.slice(line, col_start, size) |> String.to_integer(),
            check: generate_el_checks(row_number, col_start, col_end, max_row, max_col)
          }
          | acc
        ]
      end)

    row_checks ++ accumulator
  end

  defp generate_el_checks(row, col_start, col_end, max_row, max_col) do
    row_above = Enum.max([0, row - 1])
    row_below = Enum.min([max_row, row + 1])

    col_before = Enum.max([0, col_start - 1])
    col_after = Enum.min([max_col, col_end])

    range = Enum.to_list(col_before..col_after)

    [row_above, row, row_below]
    |> Enum.uniq_by(& &1)
    |> Enum.flat_map(fn row_number -> Enum.map(range, fn index -> {row_number, index} end) end)
  end

  defp get_numbers_placement_per_row(input, row) do
    Regex.scan(~r/\d+/, Enum.at(input, row), return: :index)
    |> Enum.map(&Enum.at(&1, 0))
  end
end
```

```elixir
Day3.run(input)
```

## Day 4

```elixir
input =
  Kino.FS.file_path("day_4_input.txt")
  |> File.read!()
  |> String.split("\n")
  |> Enum.filter(&(&1 != ""))
```

```elixir
require Logger

defmodule Day4 do
  def run(input) do
    part_1 =
      input
      |> Enum.map(fn card ->
        [hd, tl] = String.split(card, " | ")

        get_winning_numbers(hd)
        |> calculate_num_of_matches(get_my_numbers(tl))
        |> calculate_score()
      end)
      |> Enum.sum()

    quantities_per_card = input |> Enum.map(fn _ -> 1 end)

    part_2 =
      input
      |> Enum.with_index()
      |> Enum.reduce(quantities_per_card, fn {card, card_index}, acc ->
        [hd, tl] = String.split(card, " | ")
        num_of_matches = calculate_num_of_matches(get_winning_numbers(hd), get_my_numbers(tl))

        case num_of_matches do
          0 ->
            acc

          n ->
            curr_list = acc
            positions_to_increase = Enum.to_list((card_index + 1)..(card_index + n))
            amount_to_increase = Enum.at(acc, card_index)

            increase_numerical_list_at_positions(
              curr_list,
              positions_to_increase,
              amount_to_increase
            )
        end
      end)
      |> Enum.sum()

    {part_1, part_2}
  end

  defp get_winning_numbers(string) do
    string
    |> String.split(": ")
    |> Enum.at(1)
    |> String.split(" ")
    |> Enum.filter(&(&1 != ""))
    |> Enum.map(&String.to_integer/1)
  end

  defp get_my_numbers(string) do
    string
    |> String.split(" ")
    |> Enum.filter(&(&1 != ""))
    |> Enum.map(&String.to_integer/1)
  end

  defp calculate_num_of_matches(winning_numbers, my_numbers) do
    Enum.reduce(my_numbers, 0, fn my_num, acc ->
      case Enum.find(winning_numbers, &(&1 === my_num)) do
        nil ->
          acc

        _ ->
          acc + 1
      end
    end)
  end

  defp calculate_score(num_of_matches) do
    case num_of_matches do
      0 -> 0
      p -> 2 ** (p - 1)
    end
  end

  defp increase_numerical_list_at_positions(list, positions, increment) do
    Enum.with_index(list, fn el, idx ->
      case Enum.find(positions, &(&1 === idx)) do
        nil -> el
        _ -> el + increment
      end
    end)
  end
end
```

```elixir
Day4.run(input)
```

<!-- livebook:{"offset":9487,"stamp":{"token":"XCP.UDw_VcQgAgaDL8tesqW7xvoK4uou2ij8Re3zbkCsvHHjpPI-dta-RR48Jujd5XLoKrHDcohR97qo67MtaePOOoijW0FLAyMX-I7mO_g","version":2}} -->
